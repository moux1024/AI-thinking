<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 2ac9fffe-d0d7-4f92-8c08-78364e9e9c18 (2026-02-28 03:29Z) -->

# Introduction of skills in React (2026-02-28 03:29Z)

_**User**_

https://vercel.com/blog/introducing-react-best-practices 阅读文档, 介绍引入skill之后, 是如何工作的

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>

The user is asking me to read the Vercel blog post about React Best Practices and explain how the skill works after it's introduced/installed. I already have the blog content in the external_links section, but let me also check if there's a skill file in the workspace that was mentioned in the rules - the vercel-react-best-practices skill. I should read that skill file to give a complete answer about how it works after introduction.
</details></think>

---


正在读取工作区中的 Vercel React Best Practices skill 文件，以便准确说明引入后的工作方式。


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/moux/Desktop/Code/video-flow/.cursor/skills/vercel-react-best-practices/SKILL.md</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>

I now have a good understanding of both the Vercel blog post and the skill file. Let me summarize how the skill works after introduction for the user in Chinese.

Key points:
1. The blog introduces react-best-practices - a structured repo with 40+ rules across 8 categories
2. It's designed for AI agents and LLMs
3. The skill can be installed via `npx skills add vercel-labs/agent-skills`
4. When the agent spots issues (cascading useEffect, heavy client imports, etc.), it can reference these patterns and suggest fixes
5. The skill in this workspace (vercel-react-best-practices) has:
   - SKILL.md: description, when to apply, rule categories, quick reference
   - AGENTS.md: full compiled document with all rules expanded (incorrect/correct examples)
   - Individual rule files in rules/

How it works:
- The skill is "triggered" on tasks involving React components, Next.js pages, data fetching, bundle optimization, or performance
- The agent (Cursor) is instructed to use the skill when writing, reviewing, or refactoring React/Next.js code
- When the agent uses the skill, it reads the SKILL.md (and can read AGENTS.md or individual rule files) to get the patterns
- The agent then applies these rules - e.g. suggesting Promise.all for independent ops, avoiding barrel imports, using React.cache(), etc.
- So the workflow is: user asks for a change → agent checks if task matches skill triggers → if yes, agent loads the skill content → agent follows the rules when generating or reviewing code
</details></think>

---


根据 [Vercel 的博客](https://vercel.com/blog/introducing-react-best-practices) 和你项目里的 **vercel-react-best-practices** skill，引入 skill 之后的工作方式可以概括为下面几点。

---

## 引入 skill 之后是如何工作的

### 1. **Skill 的触发条件**

Skill 的 `description` 里写明了**何时使用**：

- 编写新的 React 组件或 Next.js 页面  
- 做数据获取（服务端或客户端）  
- 做代码审查、性能相关修改  
- 重构现有 React/Next.js 代码  
- 做 bundle 体积或加载时间优化  

当你的任务属于上述几类时，Cursor 会倾向于**加载并参考**这个 skill，而不是“自动在后台运行”。

### 2. **实际工作流程**

1. **你发起任务**  
   例如：“把这个页面改成 RSC，并优化数据请求”“给这个列表加虚拟滚动”等。

2. **Agent 判断是否适用**  
   若任务涉及 React 组件、Next.js 页面、数据获取、bundle、性能等，就会视为与 skill 相关。

3. **加载 skill 内容**  
   Agent 会去读 skill 目录下的内容，尤其是：  
   - **SKILL.md**：何时用、8 大类别、规则速查表（如 `async-parallel`、`bundle-barrel-imports` 等）  
   - 需要时还会读 **AGENTS.md** 或具体规则文件（如 `rules/async-parallel.md`），里面有错误示例、正确示例和说明。

4. **按规则生成或审查代码**  
   Agent 会结合这些规则来：  
   - **写新代码**：例如用 `Promise.all` 并行请求、用 `next/dynamic` 做按需加载、在 RSC 边界少传 props 等。  
   - **改现有代码**：发现瀑布请求、barrel 导入、重复请求等时，按规则给出修改建议或直接改。  
   - **做 code review**：对照规则指出问题并给出“正确写法”的示例。

所以，**“如何工作”** = **在相关任务下，Agent 主动读取 skill，并依里面的规则来写代码、改代码或给建议**，而不是一个独立的后台服务在跑。

### 3. **规则优先级（按影响排序）**

Skill 里把规则按**影响从高到低**排好了顺序，Agent 会优先考虑高影响项：

| 优先级 | 类别               | 影响     |
|--------|--------------------|----------|
| 1      | 消除 Waterfall     | CRITICAL |
| 2      | Bundle 体积优化    | CRITICAL |
| 3      | 服务端性能         | HIGH     |
| 4      | 客户端数据获取     | MEDIUM-HIGH |
| 5–8    | 重渲染、渲染、JS、高级模式 | MEDIUM / LOW |

这样在给你建议或改代码时，会先处理“消除请求瀑布、减小 bundle”，再处理重渲染、JS 细节等。

### 4. **和博客里说的“Agent Skills”的关系**

博客里提到：

- 这些实践被做成 **Agent Skills**，可安装到 Cursor 等编码 Agent 里。  
- 当 Agent 发现**串行的 async/useEffect、过重的客户端导入**等问题时，可以**引用这些模式并给出修改方案**。

你项目里的 **vercel-react-best-practices** 就是这类 skill 的一种实现：  
安装/配置好后，在“写/改/审” React 或 Next.js 代码时，Agent 会**按 skill 中的规则和示例**来工作，从而更一致地应用 Vercel 的 React 最佳实践。

---

**总结**：引入 skill 之后，并不是多了一个独立“程序”在跑，而是**在相关任务下，Agent 会读取这些规则和示例，并据此生成或修改代码、给出优化建议**，相当于给 Agent 加了一本“React/Next 性能最佳实践手册”并在合适场景下自动参考它。

---

_**User**_

和function call有何区别

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>

The user is asking about the difference between "skill" (as in Cursor Agent Skills, like the vercel-react-best-practices we just discussed) and "function call" (likely referring to the tool/function calling mechanism that AI assistants use - e.g. the tools I have like read_file, grep, run_terminal_cmd, etc.).

Let me explain the key differences:

1. **Skill** (in Cursor):
   - A skill is a **knowledge/guidance document** (e.g. SKILL.md + AGENTS.md + rule files) that gets **read by the agent** when the task matches the skill's trigger description.
   - It doesn't "execute" anything - it provides **context and rules** for the AI to follow when generating or reviewing code.
   - The agent **invokes** a skill by deciding to read it (based on task relevance), then the content influences the agent's reasoning and output.
   - No structured input/output like a function - it's "inject this documentation into context."

2. **Function call** (tool use):
   - A **callable tool** with a **defined schema** (name, parameters, types). The model outputs a request to call a function with specific arguments; the runtime executes it and returns a result.
   - Examples: `read_file(path)`, `grep(pattern, path)`, `run_terminal_cmd(command)`.
   - It **does something** (read file, run command, search) and returns **data** to the model.
   - The agent uses function calls to **perform actions** in the environment (file system, terminal, search, etc.).

So in short:
- **Skill** = 给模型看的「说明书/规则集」，用来约束或引导生成/审查代码；不执行代码、不返回结构化数据，只是扩充上下文。
- **Function call** = 模型调用的「可执行工具」，有明确入参和返回值，执行后把结果塞回上下文，用来读文件、跑命令、搜代码等。

I'll answer in Chinese as per user rules.
</details></think>

---


简单说，**Skill** 和 **Function Call** 是两套完全不同的机制：

---

## 1. 本质不同

| | **Skill** | **Function Call（工具调用）** |
|--|--|--|
| **是什么** | 一段给模型看的**文档/规则**（如 SKILL.md、AGENTS.md） | 一个**可执行函数**，有名字、参数、返回值 |
| **谁在用** | 模型在“做任务时”**决定要不要读**这段文档 | 模型**发起调用**，由环境**执行**并返回结果 |
| **做什么** | 提供「该怎么写/怎么改」的**知识**，影响推理和输出 | 在真实环境里**执行动作**（读文件、跑命令、搜代码等） |
| **有没有执行** | 不执行任何代码，只是把文档内容放进上下文 | 会执行代码/命令，并返回结构化数据给模型 |

---

## 2. Skill：知识注入

- 内容：最佳实践、规则、正确/错误示例等**文本**。
- 流程：任务匹配 skill 描述 → Agent **读取** skill 文件 → 内容进入上下文 → 模型按这些规则写代码/给建议。
- 不接收“参数”，也不返回“结果”；只是**改变模型看到的上下文**，从而改变它的行为。

可以理解为：**给模型一本「React 最佳实践手册」，在相关任务时翻出来参考。**

---

## 3. Function Call：工具执行

- 每个工具都有**固定接口**：名字 + 参数类型 + 返回格式。
- 流程：模型决定要做什么 → 输出一次 **function call**（例如 `read_file(path: "app/page.tsx")`）→ 环境**执行**该函数 → 把**执行结果**（文件内容、命令输出等）返回给模型。
- 会真实地**读文件、跑终端、搜代码**等，并把这些**数据**反馈给模型。

可以理解为：**模型通过「调用函数」来和你的项目、系统交互，拿到真实数据再继续推理。**

---

## 4. 对比总结

- **Skill**：  
  - 不执行、不返回数据；  
  - 提供「怎么写/怎么优化」的**规则和示例**；  
  - 通过**匹配任务 + 读取文档**来工作。

- **Function Call**：  
  - 会执行、会返回数据；  
  - 提供**读文件、搜代码、跑命令**等**能力**；  
  - 通过**模型发起调用 → 环境执行 → 返回结果**来工作。

所以：**Skill = 给模型用的「规则/知识库」；Function Call = 模型用来和外界交互的「可执行工具」**。一个是“看文档改行为”，一个是“调接口拿结果”。

---

_**User**_

function call更类似MCP吗?

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>

The user is asking whether "function call" is more similar to MCP (Model Context Protocol). Let me think about this:

1. **Function call** (in the context we discussed): The model outputs a request to invoke a tool (e.g. read_file, grep) with parameters; the runtime executes it and returns the result. It's the generic "tool use" / "function calling" mechanism that LLM APIs support.

2. **MCP (Model Context Protocol)**: MCP is a protocol that allows AI applications to connect to external data sources and tools. Servers expose "tools" and "resources" that the client (e.g. Cursor) can use. So the AI might call tools that are actually provided by an MCP server (e.g. browser automation, database, filesystem).

So:
- **Function call** = the *mechanism* (model says "call tool X with args Y" → execute → return result).
- **MCP** = one way to *provide* those tools. MCP servers define tools (and resources); the client then exposes them to the model as callable functions. So from the model's perspective, it's still "function calling" - but the implementation of those functions can come from the built-in Cursor tools (read_file, grep, etc.) OR from MCP servers (e.g. browser_navigate, git_status from GitKraken MCP).

So yes: **Function call** and **MCP** are closely related. MCP is a *source* of tools that get invoked via the same function-call mechanism. The model doesn't necessarily "know" whether a tool is from MCP or built-in; it just sees a list of tools and calls them. So function call is the general mechanism; MCP is a protocol that adds more tools (and resources) into that same mechanism.

I'll answer in Chinese.
</details></think>

---


是的，可以这么理解：**Function call 和 MCP 是同一类东西的不同层次**。

---

## 关系概览

- **Function call（函数调用）**：模型「调用一个工具」的**通用机制**——模型输出“调用谁、传什么参数”，运行时执行并把结果塞回上下文。
- **MCP（Model Context Protocol）**：一套**协议**，用来把**外部的工具（和资源）**挂到 AI 客户端上；这些工具在模型眼里也是「可调用的函数」。

所以：**MCP 是「工具的来源/协议」，Function call 是「工具被使用的方式」**。MCP 提供的工具，最终也是通过 function call 被模型调用的。

---

## 对比一下

| 维度 | Function call（泛指） | MCP |
|------|------------------------|-----|
| **是什么** | 模型调用工具的**机制/约定**（名 + 参数 → 执行 → 结果） | 定义「工具从哪来、怎么暴露」的**协议** |
| **谁提供工具** | 可以是客户端内置（如 read_file、grep） | 由 **MCP Server** 提供（如 browser、GitKraken） |
| **模型视角** | 看到一批工具，按需发起调用 | 一样：看到的仍是「工具列表 + 调用」，不关心是内置还是 MCP |
| **典型用途** | 读文件、跑命令、搜代码等 | 浏览器自动化、Git、数据库、自定义 API 等 |

---

## 结论

- **Function call** 更偏「机制」：模型如何调用一个工具、拿到结果。
- **MCP** 更偏「生态/扩展」：如何把更多工具（和资源）以统一方式接进来，再被模型用 function call 调用。

所以可以说：**Function call 和 MCP 非常接近——MCP 提供的正是通过 function call 来调用的那些工具**；区别在于 function call 是「怎么调」，MCP 是「这些可调用的工具从哪儿来、怎么接入」。

---

